//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation
import JSONUtilities

extension TFL.StopPoint {

    public enum StopPointGetByGeoPoint {

      public static let service = APIService<Response>(id: "StopPoint_GetByGeoPoint", tag: "StopPoint", method: "GET", path: "/StopPoint", hasBody: false)

      public class Request: APIRequest<Response> {

          public struct Options {

              /** a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint) */
              public var stopTypes: [String]

              /** the radius of the bounding circle in metres (default : 200) */
              public var radius: Int?

              /** Re-arrange the output into a parent/child hierarchy */
              public var useStopPointHierarchy: Bool?

              /** the list of modes to search (comma separated mode names e.g. tube,dlr) */
              public var modes: [String]?

              /** an optional list of comma separated property categories to return in the StopPoint's property bag. If null or empty, all categories of property are returned. Pass the keyword "none" to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint) */
              public var categories: [String]?

              /** true to return the lines that each stop point serves as a nested resource */
              public var returnLines: Bool?

              public var locationdotlat: Double

              public var locationdotlon: Double

              public init(stopTypes: [String], radius: Int? = nil, useStopPointHierarchy: Bool? = nil, modes: [String]? = nil, categories: [String]? = nil, returnLines: Bool? = nil, locationdotlat: Double, locationdotlon: Double) {
                  self.stopTypes = stopTypes
                  self.radius = radius
                  self.useStopPointHierarchy = useStopPointHierarchy
                  self.modes = modes
                  self.categories = categories
                  self.returnLines = returnLines
                  self.locationdotlat = locationdotlat
                  self.locationdotlon = locationdotlon
              }
          }

          public var options: Options

          public init(options: Options) {
              self.options = options
              super.init(service: StopPointGetByGeoPoint.service)
          }

          /// convenience initialiser so an Option doesn't have to be created
          public convenience init(stopTypes: [String], radius: Int? = nil, useStopPointHierarchy: Bool? = nil, modes: [String]? = nil, categories: [String]? = nil, returnLines: Bool? = nil, locationdotlat: Double, locationdotlon: Double) {
              let options = Options(stopTypes: stopTypes, radius: radius, useStopPointHierarchy: useStopPointHierarchy, modes: modes, categories: categories, returnLines: returnLines, locationdotlat: locationdotlat, locationdotlon: locationdotlon)
              self.init(options: options)
          }

          public override var parameters: [String: Any] {
              var params: JSONDictionary = [:]
              params["stopTypes"] = options.stopTypes
              if let radius = options.radius {
                params["radius"] = radius
              }
              if let useStopPointHierarchy = options.useStopPointHierarchy {
                params["useStopPointHierarchy"] = useStopPointHierarchy
              }
              if let modes = options.modes {
                params["modes"] = modes
              }
              if let categories = options.categories {
                params["categories"] = categories
              }
              if let returnLines = options.returnLines {
                params["returnLines"] = returnLines
              }
              params["location.lat"] = options.locationdotlat
              params["location.lon"] = options.locationdotlon
              return params
          }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {
            public typealias SuccessType = StopPointsResponse

            /** OK */
            case success200(StopPointsResponse)

            public var success: StopPointsResponse? {
                switch self {
                case .success200(let response): return response
                default: return nil
                }
            }

            public var response: Any {
                switch self {
                case .success200(let response): return response
                }
            }

            public var statusCode: Int {
              switch self {
              case .success200: return 200
              }
            }

            public var successful: Bool {
              switch self {
              case .success200: return true
              }
            }

            public init(statusCode: Int, data: Data) throws {
                switch statusCode {
                case 200: self = try .success200(JSONDecoder.decode(data: data))
                default: throw APIError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
