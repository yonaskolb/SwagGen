//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class JpElevation: Codable, Equatable {

    public var distance: Int?

    public var endLat: Double?

    public var endLon: Double?

    public var gradient: Double?

    public var heightFromPreviousPoint: Int?

    public var startLat: Double?

    public var startLon: Double?

    public init(distance: Int? = nil, endLat: Double? = nil, endLon: Double? = nil, gradient: Double? = nil, heightFromPreviousPoint: Int? = nil, startLat: Double? = nil, startLon: Double? = nil) {
        self.distance = distance
        self.endLat = endLat
        self.endLon = endLon
        self.gradient = gradient
        self.heightFromPreviousPoint = heightFromPreviousPoint
        self.startLat = startLat
        self.startLon = startLon
    }

    private enum CodingKeys: String, CodingKey {
        case distance
        case endLat
        case endLon
        case gradient
        case heightFromPreviousPoint
        case startLat
        case startLon
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        distance = try container.decodeIfPresent(.distance)
        endLat = try container.decodeIfPresent(.endLat)
        endLon = try container.decodeIfPresent(.endLon)
        gradient = try container.decodeIfPresent(.gradient)
        heightFromPreviousPoint = try container.decodeIfPresent(.heightFromPreviousPoint)
        startLat = try container.decodeIfPresent(.startLat)
        startLon = try container.decodeIfPresent(.startLon)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(distance, forKey: .distance)
        try container.encode(endLat, forKey: .endLat)
        try container.encode(endLon, forKey: .endLon)
        try container.encode(gradient, forKey: .gradient)
        try container.encode(heightFromPreviousPoint, forKey: .heightFromPreviousPoint)
        try container.encode(startLat, forKey: .startLat)
        try container.encode(startLon, forKey: .startLon)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? JpElevation else { return false }
      guard self.distance == object.distance else { return false }
      guard self.endLat == object.endLat else { return false }
      guard self.endLon == object.endLon else { return false }
      guard self.gradient == object.gradient else { return false }
      guard self.heightFromPreviousPoint == object.heightFromPreviousPoint else { return false }
      guard self.startLat == object.startLat else { return false }
      guard self.startLon == object.startLon else { return false }
      return true
    }

    public static func == (lhs: JpElevation, rhs: JpElevation) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
